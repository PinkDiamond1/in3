/* automatically generated by rust-bindgen */

pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type __darwin_size_t = libc::c_ulong;
pub type address_t = [u8; 20usize];
pub type bytes32_t = [u8; 32usize];
#[doc = " a byte array"]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bytes {
    #[doc = "< the byte-data"]
    pub data: *mut u8,
    #[doc = "< the length of the array ion bytes"]
    pub len: u32,
}
#[test]
fn bindgen_test_layout_bytes() {
    assert_eq!(
        ::core::mem::size_of::<bytes>(),
        16usize,
        concat!("Size of: ", stringify!(bytes))
    );
    assert_eq!(
        ::core::mem::align_of::<bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(bytes))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bytes>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bytes),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bytes>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bytes),
            "::",
            stringify!(len)
        )
    );
}
impl Clone for bytes {
    fn clone(&self) -> Self {
        *self
    }
}
pub type bytes_t = bytes;
#[doc = " string build struct, which is able to hold and modify a growing string."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sb {
    #[doc = "< the current string (null terminated)"]
    pub data: *mut libc::c_char,
    #[doc = "< number of bytes currently allocated"]
    pub allocted: usize,
    #[doc = "< the current length of the string"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_sb() {
    assert_eq!(
        ::core::mem::size_of::<sb>(),
        24usize,
        concat!("Size of: ", stringify!(sb))
    );
    assert_eq!(
        ::core::mem::align_of::<sb>(),
        8usize,
        concat!("Alignment of ", stringify!(sb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb>())).data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(sb), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb>())).allocted as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sb),
            "::",
            stringify!(allocted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb>())).len as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(sb), "::", stringify!(len))
    );
}
impl Clone for sb {
    fn clone(&self) -> Self {
        *self
    }
}
pub type sb_t = sb;
pub type d_key_t = u16;
#[doc = " a token holding any kind of value."]
#[doc = ""]
#[doc = " use d_type,  d_len or the cast-function to get the value."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct item {
    #[doc = "< the byte or string-data"]
    pub data: *mut u8,
    #[doc = "< the length of the content (or number of properties) depending +  type."]
    pub len: u32,
    #[doc = "< the key of the property."]
    pub key: d_key_t,
}
#[test]
fn bindgen_test_layout_item() {
    assert_eq!(
        ::core::mem::size_of::<item>(),
        16usize,
        concat!("Size of: ", stringify!(item))
    );
    assert_eq!(
        ::core::mem::align_of::<item>(),
        8usize,
        concat!("Alignment of ", stringify!(item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<item>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(item),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<item>())).len as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(item), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<item>())).key as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(item), "::", stringify!(key))
    );
}
impl Clone for item {
    fn clone(&self) -> Self {
        *self
    }
}
pub type d_token_t = item;
#[doc = " parser for json or binary-data. it needs to freed after usage."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct json_parser {
    #[doc = "< the list of all tokens. the first token is the main-token as returned by the parser."]
    pub result: *mut d_token_t,
    pub c: *mut libc::c_char,
    #[doc = " pointer to the src-data"]
    pub allocated: usize,
    #[doc = " amount of tokens allocated result"]
    pub len: usize,
    #[doc = " number of tokens in result"]
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_json_parser() {
    assert_eq!(
        ::core::mem::size_of::<json_parser>(),
        40usize,
        concat!("Size of: ", stringify!(json_parser))
    );
    assert_eq!(
        ::core::mem::align_of::<json_parser>(),
        8usize,
        concat!("Alignment of ", stringify!(json_parser))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<json_parser>())).result as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(json_parser),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<json_parser>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(json_parser),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<json_parser>())).allocated as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(json_parser),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<json_parser>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(json_parser),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<json_parser>())).depth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(json_parser),
            "::",
            stringify!(depth)
        )
    );
}
impl Clone for json_parser {
    fn clone(&self) -> Self {
        *self
    }
}
pub type json_ctx_t = json_parser;
#[repr(i32)]
#[doc = " ERROR types  used as return values."]
#[doc = ""]
#[doc = " All values (except IN3_OK) indicate an error."]
#[doc = " IN3_WAITING may be treated like an error, since we have stop executing until the response has arrived, but it is a valid return value."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum in3_ret_t {
    #[doc = "< Success"]
    IN3_OK = 0,
    #[doc = "< Unknown error - usually accompanied with specific error msg"]
    IN3_EUNKNOWN = -1,
    #[doc = "< No memory"]
    IN3_ENOMEM = -2,
    #[doc = "< Not supported"]
    IN3_ENOTSUP = -3,
    #[doc = "< Invalid value"]
    IN3_EINVAL = -4,
    #[doc = "< Not found"]
    IN3_EFIND = -5,
    #[doc = "< Invalid config"]
    IN3_ECONFIG = -6,
    #[doc = "< Limit reached"]
    IN3_ELIMIT = -7,
    #[doc = "< Version mismatch"]
    IN3_EVERS = -8,
    #[doc = "< Data invalid, eg. invalid/incomplete JSON"]
    IN3_EINVALDT = -9,
    #[doc = "< Wrong password"]
    IN3_EPASS = -10,
    #[doc = "< RPC error (i.e. in3_ctx_t::error set)"]
    IN3_ERPC = -11,
    #[doc = "< RPC no response"]
    IN3_ERPCNRES = -12,
    #[doc = "< USN URL parse error"]
    IN3_EUSNURL = -13,
    #[doc = "< Transport error"]
    IN3_ETRANS = -14,
    #[doc = "< Not in range"]
    IN3_ERANGE = -15,
    #[doc = "< the process can not be finished since we are waiting for responses"]
    IN3_WAITING = -16,
    #[doc = "< Ignorable error"]
    IN3_EIGNORE = -17,
}
extern "C" {
    #[doc = " converts a error code into a string."]
    #[doc = " These strings are constants and do not need to be freed."]
    pub fn in3_errmsg(err: in3_ret_t) -> *mut libc::c_char;
}
#[doc = " type for a chain_id."]
pub type chain_id_t = u32;
#[repr(u32)]
#[doc = " the type of the chain."]
#[doc = ""]
#[doc = " for incubed a chain can be any distributed network or database with incubed support."]
#[doc = " Depending on this chain-type the previously registered verifyer will be choosen and used."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum in3_chain_type_t {
    #[doc = "< Ethereum chain"]
    CHAIN_ETH = 0,
    #[doc = "< substrate chain"]
    CHAIN_SUBSTRATE = 1,
    #[doc = "< ipfs verifiaction"]
    CHAIN_IPFS = 2,
    #[doc = "< Bitcoin chain"]
    CHAIN_BTC = 3,
    #[doc = "< EOS chain"]
    CHAIN_EOS = 4,
    #[doc = "< IOTA chain"]
    CHAIN_IOTA = 5,
    #[doc = "< other chains"]
    CHAIN_GENERIC = 6,
}
#[repr(u32)]
#[doc = " the type of proof."]
#[doc = ""]
#[doc = " Depending on the proof-type different levels of proof will be requested from the node."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum in3_proof_t {
    #[doc = "< No Verification"]
    PROOF_NONE = 0,
    #[doc = "< Standard Verification of the important properties"]
    PROOF_STANDARD = 1,
    #[doc = "< All field will be validated including uncles"]
    PROOF_FULL = 2,
}
#[repr(u32)]
#[doc = " verification as delivered by the server."]
#[doc = ""]
#[doc = " This will be part of the in3-request and will be generated based on the prooftype."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum in3_verification_t {
    #[doc = "< No Verifacation"]
    VERIFICATION_NEVER = 0,
    #[doc = "< Includes the proof of the data"]
    VERIFICATION_PROOF = 1,
}
#[doc = " the configuration as part of each incubed request."]
#[doc = " This will be generated for each request based on the client-configuration. the verifier may access this during verification in order to check against the request."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_request_config {
    #[doc = "< the chain to be used. this is holding the integer-value of the hexstring."]
    pub chain_id: chain_id_t,
    #[doc = "< the current flags from the client."]
    pub flags: uint_fast8_t,
    #[doc = "< this flaqg is set, if the proof is set to \"PROOF_FULL\""]
    pub use_full_proof: u8,
    #[doc = "< a list of blockhashes already verified. The Server will not send any proof for them again ."]
    pub verified_hashes: *mut bytes_t,
    #[doc = "< number of verified blockhashes"]
    pub verified_hashes_length: u16,
    #[doc = "< the last blocknumber the nodelistz changed"]
    pub latest_block: u8,
    #[doc = "< number of signatures( in percent) needed in order to reach finality."]
    pub finality: u16,
    #[doc = "< Verification-type"]
    pub verification: in3_verification_t,
    #[doc = "< the addresses of servers requested to sign the blockhash"]
    pub signers: *mut bytes_t,
    #[doc = "< number or addresses"]
    pub signers_length: u8,
    #[doc = "< meassured time in ms for the request"]
    pub time: u32,
}
#[test]
fn bindgen_test_layout_in3_request_config() {
    assert_eq!(
        ::core::mem::size_of::<in3_request_config>(),
        48usize,
        concat!("Size of: ", stringify!(in3_request_config))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_request_config>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_request_config))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_request_config>())).chain_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(chain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_request_config>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_request_config>())).use_full_proof as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(use_full_proof)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_request_config>())).verified_hashes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(verified_hashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_request_config>())).verified_hashes_length as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(verified_hashes_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_request_config>())).latest_block as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(latest_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_request_config>())).finality as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(finality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_request_config>())).verification as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(verification)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_request_config>())).signers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(signers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_request_config>())).signers_length as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(signers_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_request_config>())).time as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_request_config),
            "::",
            stringify!(time)
        )
    );
}
impl Clone for in3_request_config {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_request_config_t = in3_request_config;
#[doc = " Node capabilities"]
#[doc = " @note Always access using getters/setters in nodelist.h"]
pub type in3_node_props_t = u64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum in3_node_props_type_t {
    #[doc = "< filter out nodes which are providing no proof"]
    NODE_PROP_PROOF = 1,
    #[doc = "< filter out nodes other then which have capability of the same RPC endpoint may also accept requests for different chains"]
    NODE_PROP_MULTICHAIN = 2,
    #[doc = "< filter out non-archive supporting nodes"]
    NODE_PROP_ARCHIVE = 4,
    #[doc = "< filter out non-http nodes"]
    NODE_PROP_HTTP = 8,
    #[doc = "< filter out nodes that don't support binary encoding"]
    NODE_PROP_BINARY = 16,
    #[doc = "< filter out non-onion nodes"]
    NODE_PROP_ONION = 32,
    #[doc = "< filter out non-signer nodes"]
    NODE_PROP_SIGNER = 64,
    #[doc = "< filter out non-data provider nodes"]
    NODE_PROP_DATA = 128,
    #[doc = "< filter out nodes that do not provide stats"]
    NODE_PROP_STATS = 256,
    #[doc = "< filter out nodes that will sign blocks with lower min block height than specified"]
    NODE_PROP_MIN_BLOCK_HEIGHT = 1024,
}
#[repr(u32)]
#[doc = " a list of flags definiing the behavior of the incubed client. They should be used as bitmask for the flags-property."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum in3_flags_type_t {
    #[doc = "< the in3-section with the proof will also returned"]
    FLAGS_KEEP_IN3 = 1,
    #[doc = "< the nodelist will be automaticly updated if the last_block is newer"]
    FLAGS_AUTO_UPDATE_LIST = 2,
    #[doc = "< the code is included when sending eth_call-requests"]
    FLAGS_INCLUDE_CODE = 4,
    #[doc = "< the client will use binary format"]
    FLAGS_BINARY = 8,
    #[doc = "< the client will try to use http instead of https"]
    FLAGS_HTTP = 16,
    #[doc = "< nodes will keep track of the stats (default=true)"]
    FLAGS_STATS = 32,
    #[doc = "< nodelist update request will not automatically ask for signatures and proof"]
    FLAGS_NODE_LIST_NO_SIG = 64,
}
#[doc = " incubed node-configuration."]
#[doc = ""]
#[doc = " These information are read from the Registry contract and stored in this struct representing a server or node."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_node {
    #[doc = "< address of the server"]
    pub address: *mut bytes_t,
    #[doc = "< the deposit stored in the registry contract, which this would lose if it sends a wrong blockhash"]
    pub deposit: u64,
    #[doc = "< index within the nodelist, also used in the contract as key"]
    pub index: u32,
    #[doc = "< the maximal capacity able to handle"]
    pub capacity: u32,
    #[doc = "< used to identify the capabilities of the node. See in3_node_props_type_t in nodelist.h"]
    pub props: in3_node_props_t,
    #[doc = "< the url of the node"]
    pub url: *mut libc::c_char,
    #[doc = "< boolean indicating if node exists in whiteList"]
    pub whitelisted: bool,
    #[doc = "< internal - used to avoid filtering manually added nodes before first nodeList update"]
    pub boot_node: bool,
}
#[test]
fn bindgen_test_layout_in3_node() {
    assert_eq!(
        ::core::mem::size_of::<in3_node>(),
        48usize,
        concat!("Size of: ", stringify!(in3_node))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_node>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).deposit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(deposit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).capacity as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).props as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).url as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).whitelisted as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(whitelisted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node>())).boot_node as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node),
            "::",
            stringify!(boot_node)
        )
    );
}
impl Clone for in3_node {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_node_t = in3_node;
#[doc = " Weight or reputation of a node."]
#[doc = ""]
#[doc = " Based on the past performance of the node a weight is calculated given faster nodes a higher weight"]
#[doc = " and chance when selecting the next node from the nodelist."]
#[doc = " These weights will also be stored in the cache (if available)"]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_node_weight {
    #[doc = "< counter for responses"]
    pub response_count: u32,
    #[doc = "< total of all response times"]
    pub total_response_time: u32,
    #[doc = "< if >0 this node is blacklisted until k. k is a unix timestamp"]
    pub blacklisted_until: u64,
}
#[test]
fn bindgen_test_layout_in3_node_weight() {
    assert_eq!(
        ::core::mem::size_of::<in3_node_weight>(),
        16usize,
        concat!("Size of: ", stringify!(in3_node_weight))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_node_weight>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_node_weight))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_node_weight>())).response_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node_weight),
            "::",
            stringify!(response_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_node_weight>())).total_response_time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node_weight),
            "::",
            stringify!(total_response_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_node_weight>())).blacklisted_until as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_node_weight),
            "::",
            stringify!(blacklisted_until)
        )
    );
}
impl Clone for in3_node_weight {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_node_weight_t = in3_node_weight;
extern "C" {
    #[doc = " setter method for interacting with in3_node_props_t."]
    #[doc = " @param[out] node_props"]
    #[doc = " @param type"]
    #[doc = " @param"]
    pub fn in3_node_props_set(
        node_props: *mut in3_node_props_t,
        type_: in3_node_props_type_t,
        value: u8,
    );
}
#[doc = " defines a whitelist structure used for the nodelist."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_whitelist {
    #[doc = "< address of whiteList contract. If specified, whiteList is always auto-updated and manual whiteList is overridden"]
    pub contract: address_t,
    #[doc = "< serialized list of node addresses that constitute the whiteList"]
    pub addresses: bytes_t,
    #[doc = "< last blocknumber the whiteList was updated, which is used to detect changed in the whitelist"]
    pub last_block: u64,
    #[doc = "< if true the nodelist should be updated and will trigger a `in3_nodeList`-request before the next request is send."]
    pub needs_update: bool,
}
#[test]
fn bindgen_test_layout_in3_whitelist() {
    assert_eq!(
        ::core::mem::size_of::<in3_whitelist>(),
        56usize,
        concat!("Size of: ", stringify!(in3_whitelist))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_whitelist>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_whitelist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_whitelist>())).contract as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_whitelist),
            "::",
            stringify!(contract)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_whitelist>())).addresses as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_whitelist),
            "::",
            stringify!(addresses)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_whitelist>())).last_block as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_whitelist),
            "::",
            stringify!(last_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_whitelist>())).needs_update as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_whitelist),
            "::",
            stringify!(needs_update)
        )
    );
}
impl Clone for in3_whitelist {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_whitelist_t = in3_whitelist;
#[doc = "represents a blockhash which was previously verified"]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_verified_hash {
    #[doc = "< the number of the block"]
    pub block_number: u64,
    #[doc = "< the blockhash"]
    pub hash: bytes32_t,
}
#[test]
fn bindgen_test_layout_in3_verified_hash() {
    assert_eq!(
        ::core::mem::size_of::<in3_verified_hash>(),
        40usize,
        concat!("Size of: ", stringify!(in3_verified_hash))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_verified_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_verified_hash))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_verified_hash>())).block_number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_verified_hash),
            "::",
            stringify!(block_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_verified_hash>())).hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_verified_hash),
            "::",
            stringify!(hash)
        )
    );
}
impl Clone for in3_verified_hash {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_verified_hash_t = in3_verified_hash;
#[doc = " Chain definition inside incubed."]
#[doc = ""]
#[doc = " for incubed a chain can be any distributed network or database with incubed support."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_chain {
    #[doc = "< chain_id, which could be a free or based on the public ethereum networkId"]
    pub chain_id: chain_id_t,
    #[doc = "< chaintype"]
    pub type_: in3_chain_type_t,
    #[doc = "< last blocknumber the nodeList was updated, which is used to detect changed in the nodelist"]
    pub last_block: u64,
    #[doc = "< number of nodes in the nodeList"]
    pub nodelist_length: libc::c_int,
    #[doc = "< array of nodes"]
    pub nodelist: *mut in3_node_t,
    #[doc = "< stats and weights recorded for each node"]
    pub weights: *mut in3_node_weight_t,
    #[doc = "< array of addresses of nodes that should always part of the nodeList"]
    pub init_addresses: *mut *mut bytes_t,
    #[doc = "< the address of the registry contract"]
    pub contract: *mut bytes_t,
    #[doc = "< the identifier of the registry"]
    pub registry_id: bytes32_t,
    #[doc = "< version of the chain"]
    pub version: u8,
    #[doc = "< contains the list of already verified blockhashes"]
    pub verified_hashes: *mut in3_verified_hash_t,
    #[doc = "< if set the whitelist of the addresses."]
    pub whitelist: *mut in3_whitelist_t,
    #[doc = "< average block time (seconds) for this chain (calculated internally)"]
    pub avg_block_time: u16,
    pub nodelist_upd8_params: *mut in3_chain__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_chain__bindgen_ty_1 {
    #[doc = "< node that reported the last_block which necessitated a nodeList update"]
    pub node: address_t,
    #[doc = "< the last_block when the nodelist last changed reported by this node"]
    pub exp_last_block: u64,
    #[doc = "< approx. time when nodelist must be updated (i.e. when reported last_block will be considered final)"]
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_in3_chain__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<in3_chain__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(in3_chain__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_chain__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_chain__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain__bindgen_ty_1>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain__bindgen_ty_1),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_chain__bindgen_ty_1>())).exp_last_block as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain__bindgen_ty_1),
            "::",
            stringify!(exp_last_block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_chain__bindgen_ty_1>())).timestamp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain__bindgen_ty_1),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Clone for in3_chain__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_in3_chain() {
    assert_eq!(
        ::core::mem::size_of::<in3_chain>(),
        128usize,
        concat!("Size of: ", stringify!(in3_chain))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_chain>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_chain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).chain_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(chain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).last_block as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(last_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).nodelist_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(nodelist_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).nodelist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(nodelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).weights as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(weights)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).init_addresses as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(init_addresses)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).contract as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(contract)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).registry_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(registry_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).version as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).verified_hashes as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(verified_hashes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).whitelist as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).avg_block_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(avg_block_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_chain>())).nodelist_upd8_params as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_chain),
            "::",
            stringify!(nodelist_upd8_params)
        )
    );
}
impl Clone for in3_chain {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_chain_t = in3_chain;
#[doc = " storage handler function for reading from cache."]
#[doc = " @returns the found result. if the key is found this function should return the values as bytes otherwise `NULL`."]
pub type in3_storage_get_item = ::core::option::Option<
    unsafe extern "C" fn(cptr: *mut libc::c_void, key: *mut libc::c_char) -> *mut bytes_t,
>;
#[doc = " storage handler function for writing to the cache."]
pub type in3_storage_set_item = ::core::option::Option<
    unsafe extern "C" fn(cptr: *mut libc::c_void, key: *mut libc::c_char, value: *mut bytes_t),
>;
#[doc = " storage handler function for clearing the cache."]
pub type in3_storage_clear = ::core::option::Option<unsafe extern "C" fn(cptr: *mut libc::c_void)>;
#[doc = " storage handler to handle cache."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_storage_handler {
    #[doc = "< function pointer returning a stored value for the given key."]
    pub get_item: in3_storage_get_item,
    #[doc = "< function pointer setting a stored value for the given key."]
    pub set_item: in3_storage_set_item,
    #[doc = "< function pointer clearing all contents of cache."]
    pub clear: in3_storage_clear,
    #[doc = "< custom pointer which will be passed to functions"]
    pub cptr: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_in3_storage_handler() {
    assert_eq!(
        ::core::mem::size_of::<in3_storage_handler>(),
        32usize,
        concat!("Size of: ", stringify!(in3_storage_handler))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_storage_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_storage_handler))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_storage_handler>())).get_item as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_storage_handler),
            "::",
            stringify!(get_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_storage_handler>())).set_item as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_storage_handler),
            "::",
            stringify!(set_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_storage_handler>())).clear as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_storage_handler),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_storage_handler>())).cptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_storage_handler),
            "::",
            stringify!(cptr)
        )
    );
}
impl Clone for in3_storage_handler {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_storage_handler_t = in3_storage_handler;
#[repr(u32)]
#[doc = " type of the requested signature"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum d_signature_type_t {
    #[doc = "< sign the data directly"]
    SIGN_EC_RAW = 0,
    #[doc = "< hash and sign the data"]
    SIGN_EC_HASH = 1,
}
#[doc = " signing function."]
#[doc = ""]
#[doc = " signs the given data and write the signature to dst."]
#[doc = " the return value must be the number of bytes written to dst."]
#[doc = " In case of an error a negativ value must be returned. It should be one of the IN3_SIGN_ERR... values."]
pub type in3_sign = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut libc::c_void,
        type_: d_signature_type_t,
        message: bytes_t,
        account: bytes_t,
        dst: *mut u8,
    ) -> in3_ret_t,
>;
#[doc = " transform transaction function."]
#[doc = ""]
#[doc = " for multisigs, we need to change the transaction to gro through the ms."]
#[doc = " if the new_tx is not set within the function, it will use the old_tx."]
pub type in3_prepare_tx = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut libc::c_void,
        old_tx: *mut d_token_t,
        new_tx: *mut *mut json_ctx_t,
    ) -> in3_ret_t,
>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_signer {
    pub sign: in3_sign,
    pub prepare_tx: in3_prepare_tx,
    pub wallet: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_in3_signer() {
    assert_eq!(
        ::core::mem::size_of::<in3_signer>(),
        24usize,
        concat!("Size of: ", stringify!(in3_signer))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_signer>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_signer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_signer>())).sign as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_signer),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_signer>())).prepare_tx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_signer),
            "::",
            stringify!(prepare_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_signer>())).wallet as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_signer),
            "::",
            stringify!(wallet)
        )
    );
}
impl Clone for in3_signer {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_signer_t = in3_signer;
#[doc = " response-object."]
#[doc = ""]
#[doc = " if the error has a length>0 the response will be rejected"]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct n3_response {
    #[doc = "< a stringbuilder to add any errors!"]
    pub error: sb_t,
    #[doc = "< a stringbuilder to add the result"]
    pub result: sb_t,
}
#[test]
fn bindgen_test_layout_n3_response() {
    assert_eq!(
        ::core::mem::size_of::<n3_response>(),
        48usize,
        concat!("Size of: ", stringify!(n3_response))
    );
    assert_eq!(
        ::core::mem::align_of::<n3_response>(),
        8usize,
        concat!("Alignment of ", stringify!(n3_response))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_response>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_response),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_response>())).result as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_response),
            "::",
            stringify!(result)
        )
    );
}
impl Clone for n3_response {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_response_t = n3_response;
#[doc = " request-object."]
#[doc = ""]
#[doc = " represents a RPC-request"]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct n3_request {
    #[doc = "< the payload to send"]
    pub payload: *mut libc::c_char,
    #[doc = "< array of urls"]
    pub urls: *mut *mut libc::c_char,
    #[doc = "< number of urls"]
    pub urls_len: libc::c_int,
    #[doc = "< the responses"]
    pub results: *mut in3_response_t,
    #[doc = "< the timeout 0= no timeout"]
    pub timeout: u32,
    #[doc = "< measured times (in ms) which will be used for ajusting the weights"]
    pub times: *mut u32,
}
#[test]
fn bindgen_test_layout_n3_request() {
    assert_eq!(
        ::core::mem::size_of::<n3_request>(),
        48usize,
        concat!("Size of: ", stringify!(n3_request))
    );
    assert_eq!(
        ::core::mem::align_of::<n3_request>(),
        8usize,
        concat!("Alignment of ", stringify!(n3_request))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_request>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_request),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_request>())).urls as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_request),
            "::",
            stringify!(urls)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_request>())).urls_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_request),
            "::",
            stringify!(urls_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_request>())).results as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_request),
            "::",
            stringify!(results)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_request>())).timeout as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_request),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<n3_request>())).times as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(n3_request),
            "::",
            stringify!(times)
        )
    );
}
impl Clone for n3_request {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_request_t = n3_request;
#[doc = " the transport function to be implemented by the transport provider."]
pub type in3_transport_send =
    ::core::option::Option<unsafe extern "C" fn(request: *mut in3_request_t) -> in3_ret_t>;
#[repr(u32)]
#[doc = " Filter type used internally when managing filters."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum in3_filter_type_t {
    #[doc = "< Event filter"]
    FILTER_EVENT = 0,
    #[doc = "< Block filter"]
    FILTER_BLOCK = 1,
    #[doc = "< Pending filter (Unsupported)"]
    FILTER_PENDING = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_filter_t_ {
    #[doc = " filter type: (event, block or pending)"]
    pub type_: in3_filter_type_t,
    #[doc = " associated filter options"]
    pub options: *mut libc::c_char,
    #[doc = " block no. when filter was created OR eth_getFilterChanges was called"]
    pub last_block: u64,
    #[doc = " if true the filter was not used previously"]
    pub is_first_usage: bool,
    #[doc = " method to release owned resources"]
    pub release: ::core::option::Option<unsafe extern "C" fn(f: *mut in3_filter_t_)>,
}
#[test]
fn bindgen_test_layout_in3_filter_t_() {
    assert_eq!(
        ::core::mem::size_of::<in3_filter_t_>(),
        40usize,
        concat!("Size of: ", stringify!(in3_filter_t_))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_filter_t_>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_filter_t_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_filter_t_>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_filter_t_),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_filter_t_>())).options as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_filter_t_),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_filter_t_>())).last_block as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_filter_t_),
            "::",
            stringify!(last_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_filter_t_>())).is_first_usage as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_filter_t_),
            "::",
            stringify!(is_first_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_filter_t_>())).release as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_filter_t_),
            "::",
            stringify!(release)
        )
    );
}
impl Clone for in3_filter_t_ {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_filter_t = in3_filter_t_;
#[doc = " Handler which is added to client config in order to handle filter."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_filter_handler_t_ {
    pub array: *mut *mut in3_filter_t,
    #[doc = " array of filters"]
    pub count: usize,
}
#[test]
fn bindgen_test_layout_in3_filter_handler_t_() {
    assert_eq!(
        ::core::mem::size_of::<in3_filter_handler_t_>(),
        16usize,
        concat!("Size of: ", stringify!(in3_filter_handler_t_))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_filter_handler_t_>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_filter_handler_t_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_filter_handler_t_>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_filter_handler_t_),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_filter_handler_t_>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_filter_handler_t_),
            "::",
            stringify!(count)
        )
    );
}
impl Clone for in3_filter_handler_t_ {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_filter_handler_t = in3_filter_handler_t_;
#[doc = " Incubed Configuration."]
#[doc = ""]
#[doc = " This struct holds the configuration and also point to internal resources such as filters or chain configs."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_t_ {
    #[doc = " number of seconds requests can be cached."]
    pub cache_timeout: u32,
    #[doc = " the limit of nodes to store in the client."]
    pub node_limit: u16,
    #[doc = " the client key to sign requests (pointer to 32bytes private key seed)"]
    pub key: *mut libc::c_void,
    #[doc = " number of max bytes used to cache the code in memory"]
    pub max_code_cache: u32,
    #[doc = " number of number of blocks cached  in memory"]
    pub max_block_cache: u32,
    #[doc = " the type of proof used"]
    pub proof: in3_proof_t,
    #[doc = " the number of request send when getting a first answer"]
    pub request_count: u8,
    #[doc = " the number of signatures used to proof the blockhash."]
    pub signature_count: u8,
    #[doc = " min stake of the server. Only nodes owning at least this amount will be chosen."]
    pub min_deposit: u64,
    #[doc = " if specified, the blocknumber *latest* will be replaced by blockNumber- specified value"]
    pub replace_latest_block: u8,
    #[doc = " the number of signatures in percent required for the request"]
    pub finality: u16,
    #[doc = " the max number of attempts before giving up"]
    pub max_attempts: uint_fast16_t,
    #[doc = " max number of verified hashes to cache"]
    pub max_verified_hashes: uint_fast16_t,
    #[doc = " specifies the number of milliseconds before the request times out. increasing may be helpful if the device uses a slow connection."]
    pub timeout: u32,
    #[doc = " servers to filter for the given chain. The chain-id based on EIP-155."]
    pub chain_id: chain_id_t,
    #[doc = " a cache handler offering 2 functions ( setItem(string,string), getItem(string) )"]
    pub cache: *mut in3_storage_handler_t,
    #[doc = " signer-struct managing a wallet"]
    pub signer: *mut in3_signer_t,
    #[doc = " the transporthandler sending requests"]
    pub transport: in3_transport_send,
    #[doc = " a bit mask with flags defining the behavior of the incubed client. See the FLAG...-defines"]
    pub flags: uint_fast8_t,
    #[doc = " chain spec and nodeList definitions"]
    pub chains: *mut in3_chain_t,
    #[doc = " number of configured chains"]
    pub chains_length: u16,
    #[doc = " filter handler"]
    pub filters: *mut in3_filter_handler_t,
    #[doc = " used to identify the capabilities of the node."]
    pub node_props: in3_node_props_t,
}
#[test]
fn bindgen_test_layout_in3_t_() {
    assert_eq!(
        ::core::mem::size_of::<in3_t_>(),
        120usize,
        concat!("Size of: ", stringify!(in3_t_))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_t_>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_t_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).cache_timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(cache_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).node_limit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(node_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).max_code_cache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(max_code_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).max_block_cache as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(max_block_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).proof as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(proof)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).request_count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(request_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).signature_count as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(signature_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).min_deposit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(min_deposit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).replace_latest_block as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(replace_latest_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).finality as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(finality)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).max_attempts as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(max_attempts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).max_verified_hashes as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(max_verified_hashes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).timeout as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).chain_id as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(chain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).cache as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).signer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(signer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).transport as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).chains as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(chains)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).chains_length as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(chains_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).filters as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_t_>())).node_props as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_t_),
            "::",
            stringify!(node_props)
        )
    );
}
impl Clone for in3_t_ {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_t = in3_t_;
extern "C" {
    #[doc = " creates a new Incubes configuration and returns the pointer."]
    #[doc = ""]
    #[doc = " This Method is depricated. you should use `in3_for_chain(ETH_CHAIN_ID_MULTICHAIN)` instead."]
    #[doc = ""]
    #[doc = " you need to free this instance with `in3_free` after use!"]
    #[doc = ""]
    #[doc = " Before using the client you still need to set the tramsport and optional the storage handlers:"]
    #[doc = ""]
    #[doc = "  * example of initialization:"]
    #[doc = " ```c"]
    #[doc = " // register verifiers"]
    #[doc = " in3_register_eth_full();"]
    #[doc = ""]
    #[doc = " // create new client"]
    #[doc = " in3_t* client = in3_new();"]
    #[doc = ""]
    #[doc = " // configure storage..."]
    #[doc = " in3_storage_handler_t storage_handler;"]
    #[doc = " storage_handler.get_item = storage_get_item;"]
    #[doc = " storage_handler.set_item = storage_set_item;"]
    #[doc = " storage_handler.clear = storage_clear;"]
    #[doc = ""]
    #[doc = " // configure transport"]
    #[doc = " client->transport    = send_curl;"]
    #[doc = ""]
    #[doc = " // configure storage"]
    #[doc = " client->cache = &storage_handler;"]
    #[doc = ""]
    #[doc = " // init cache"]
    #[doc = " in3_cache_init(client);"]
    #[doc = ""]
    #[doc = " // ready to use ..."]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " @returns the incubed instance."]
    pub fn in3_new() -> *mut in3_t;
}
extern "C" {
    #[doc = " creates a new Incubes configuration for a specified chain and returns the pointer."]
    #[doc = " when creating the client only the one chain will be configured. (saves memory)."]
    #[doc = " but if you pass `ETH_CHAIN_ID_MULTICHAIN` as argument all known chains will be configured allowing you to switch between chains within the same client or configuring your own chain."]
    #[doc = ""]
    #[doc = " you need to free this instance with `in3_free` after use!"]
    #[doc = ""]
    #[doc = " Before using the client you still need to set the tramsport and optional the storage handlers:"]
    #[doc = ""]
    #[doc = "  * example of initialization:"]
    #[doc = " ```c"]
    #[doc = " // register verifiers"]
    #[doc = " in3_register_eth_full();"]
    #[doc = ""]
    #[doc = " // create new client"]
    #[doc = " in3_t* client = in3_for_chain(ETH_CHAIN_ID_MAINNET);"]
    #[doc = ""]
    #[doc = " // configure storage..."]
    #[doc = " in3_storage_handler_t storage_handler;"]
    #[doc = " storage_handler.get_item = storage_get_item;"]
    #[doc = " storage_handler.set_item = storage_set_item;"]
    #[doc = " storage_handler.clear = storage_clear;"]
    #[doc = ""]
    #[doc = " // configure transport"]
    #[doc = " client->transport    = send_curl;"]
    #[doc = ""]
    #[doc = " // configure storage"]
    #[doc = " client->cache = &storage_handler;"]
    #[doc = ""]
    #[doc = " // init cache"]
    #[doc = " in3_cache_init(client);"]
    #[doc = ""]
    #[doc = " // ready to use ..."]
    #[doc = " ```"]
    #[doc = " ** This Method is depricated. you should use `in3_for_chain` instead.**"]
    #[doc = ""]
    #[doc = " @returns the incubed instance."]
    pub fn in3_for_chain(chain_id: chain_id_t) -> *mut in3_t;
}
extern "C" {
    #[doc = " sends a request and stores the result in the provided buffer"]
    pub fn in3_client_rpc(
        c: *mut in3_t,
        method: *mut libc::c_char,
        params: *mut libc::c_char,
        result: *mut *mut libc::c_char,
        error: *mut *mut libc::c_char,
    ) -> in3_ret_t;
}
extern "C" {
    #[doc = " sends a request and stores the result in the provided buffer"]
    pub fn in3_client_rpc_raw(
        c: *mut in3_t,
        request: *mut libc::c_char,
        result: *mut *mut libc::c_char,
        error: *mut *mut libc::c_char,
    ) -> in3_ret_t;
}
extern "C" {
    #[doc = " executes a request and returns result as string. in case of an error, the error-property of the result will be set."]
    #[doc = " The resulting string must be free by the the caller of this function!"]
    pub fn in3_client_exec_req(c: *mut in3_t, req: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " adds a response for a request-object."]
    #[doc = " This function should be used in the transport-function to set the response."]
    pub fn in3_req_add_response(
        res: *mut in3_response_t,
        index: libc::c_int,
        is_error: bool,
        data: *mut libc::c_void,
        data_len: libc::c_int,
    );
}
extern "C" {
    #[doc = " registers a new chain or replaces a existing (but keeps the nodelist)"]
    pub fn in3_client_register_chain(
        client: *mut in3_t,
        chain_id: chain_id_t,
        type_: in3_chain_type_t,
        contract: *mut u8,
        registry_id: *mut u8,
        version: u8,
        wl_contract: *mut u8,
    ) -> in3_ret_t;
}
extern "C" {
    #[doc = " adds a node to a chain ore updates a existing node"]
    pub fn in3_client_add_node(
        client: *mut in3_t,
        chain_id: chain_id_t,
        url: *mut libc::c_char,
        props: in3_node_props_t,
        address: *mut u8,
    ) -> in3_ret_t;
}
extern "C" {
    #[doc = " removes a node from a nodelist"]
    pub fn in3_client_remove_node(
        client: *mut in3_t,
        chain_id: chain_id_t,
        address: *mut u8,
    ) -> in3_ret_t;
}
extern "C" {
    #[doc = " removes all nodes from the nodelist"]
    pub fn in3_client_clear_nodes(client: *mut in3_t, chain_id: chain_id_t) -> in3_ret_t;
}
extern "C" {
    #[doc = " frees the references of the client"]
    pub fn in3_free(a: *mut in3_t);
}
extern "C" {
    #[doc = " inits the cache."]
    #[doc = ""]
    #[doc = " this will try to read the nodelist from cache."]
    pub fn in3_cache_init(c: *mut in3_t) -> in3_ret_t;
}
extern "C" {
    #[doc = " finds the chain-config for the given chain_id."]
    #[doc = ""]
    #[doc = " My return NULL if not found."]
    pub fn in3_find_chain(c: *mut in3_t, chain_id: chain_id_t) -> *mut in3_chain_t;
}
extern "C" {
    #[doc = " configures the clent based on a json-config."]
    #[doc = ""]
    #[doc = " For details about the structure of ther config see https://in3.readthedocs.io/en/develop/api-ts.html#type-in3config"]
    #[doc = " Returns NULL on success, and error string on failure (to be freed by caller) - in which case the client state is undefined"]
    pub fn in3_configure(c: *mut in3_t, config: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " defines a default transport which is used when creating a new client."]
    pub fn in3_set_default_transport(transport: in3_transport_send);
}
extern "C" {
    #[doc = " defines a default storage handler which is used when creating a new client."]
    pub fn in3_set_default_storage(cacheStorage: *mut in3_storage_handler_t);
}
extern "C" {
    #[doc = " defines a default signer which is used when creating a new client."]
    pub fn in3_set_default_signer(signer: *mut in3_signer_t);
}
extern "C" {
    #[doc = " create a new signer-object to be set on the client."]
    #[doc = " the caller will need to free this pointer after usage."]
    pub fn in3_create_signer(
        sign: in3_sign,
        prepare_tx: in3_prepare_tx,
        wallet: *mut libc::c_void,
    ) -> *mut in3_signer_t;
}
extern "C" {
    #[doc = " create a new storage handler-object to be set on the client."]
    #[doc = " the caller will need to free this pointer after usage."]
    pub fn in3_create_storage_handler(
        get_item: in3_storage_get_item,
        set_item: in3_storage_set_item,
        clear: in3_storage_clear,
        cptr: *mut libc::c_void,
    ) -> *mut in3_storage_handler_t;
}
extern "C" {
    pub fn in3_register_eth_api();
}
#[doc = " represents a single cache entry in a linked list."]
#[doc = " These are used within a request context to cache values and automaticly free them."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cache_entry {
    #[doc = "<  an optional key of the entry"]
    pub key: bytes_t,
    #[doc = "< the value"]
    pub value: bytes_t,
    #[doc = "< the buffer is used to store extra data, which will be cleaned when freed."]
    pub buffer: [u8; 4usize],
    #[doc = "< if true, the cache-entry will be freed when the request context is cleaned up."]
    pub must_free: bool,
    #[doc = "< pointer to the next entry."]
    pub next: *mut cache_entry,
}
#[test]
fn bindgen_test_layout_cache_entry() {
    assert_eq!(
        ::core::mem::size_of::<cache_entry>(),
        48usize,
        concat!("Size of: ", stringify!(cache_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<cache_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(cache_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cache_entry>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cache_entry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cache_entry>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cache_entry),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cache_entry>())).buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cache_entry),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cache_entry>())).must_free as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cache_entry),
            "::",
            stringify!(must_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cache_entry>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cache_entry),
            "::",
            stringify!(next)
        )
    );
}
impl Clone for cache_entry {
    fn clone(&self) -> Self {
        *self
    }
}
pub type cache_entry_t = cache_entry;
extern "C" {
    #[doc = " get the entry for a given key."]
    pub fn in3_cache_get_entry(cache: *mut cache_entry_t, key: *mut bytes_t) -> *mut bytes_t;
}
extern "C" {
    #[doc = " adds an entry to the linked list."]
    pub fn in3_cache_add_entry(
        cache: *mut *mut cache_entry_t,
        key: bytes_t,
        value: bytes_t,
    ) -> *mut cache_entry_t;
}
extern "C" {
    #[doc = " clears all entries in the linked list."]
    pub fn in3_cache_free(cache: *mut cache_entry_t);
}
#[doc = " time function"]
#[doc = " defaults to k_uptime_get() for zeohyr and time(NULL) for other platforms"]
#[doc = " expected to return a u64 value representative of time (from epoch/start)"]
pub type time_func = ::core::option::Option<unsafe extern "C" fn(t: *mut libc::c_void) -> u64>;
extern "C" {
    pub fn in3_set_func_time(fn_: time_func);
}
extern "C" {
    pub fn in3_time(t: *mut libc::c_void) -> u64;
}
#[doc = " rand function"]
#[doc = " defaults to k_uptime_get() for zeohyr and rand() for other platforms"]
#[doc = " expected to return a random number"]
pub type rand_func =
    ::core::option::Option<unsafe extern "C" fn(s: *mut libc::c_void) -> libc::c_int>;
extern "C" {
    pub fn in3_set_func_rand(fn_: rand_func);
}
extern "C" {
    pub fn in3_rand(s: *mut libc::c_void) -> libc::c_int;
}
#[doc = " srand function"]
#[doc = " defaults to NOOP for zephyr and srand() for other platforms"]
#[doc = " expected to set the seed for a new sequence of random numbers to be returned by in3_rand()"]
pub type srand_func = ::core::option::Option<unsafe extern "C" fn(s: libc::c_uint)>;
extern "C" {
    pub fn in3_set_func_srand(fn_: srand_func);
}
extern "C" {
    pub fn in3_srand(s: libc::c_uint);
}
#[repr(u32)]
#[doc = " type of the request context,"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ctx_type {
    #[doc = "< a json-rpc request, which needs to be send to a incubed node"]
    CT_RPC = 0,
    #[doc = "< a sign request"]
    CT_SIGN = 1,
}
pub use self::ctx_type as ctx_type_t;
#[doc = " the weight of a certain node as linked list."]
#[doc = ""]
#[doc = " This will be used when picking the nodes to send the request to. A linked list of these structs desribe the result."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct weight {
    #[doc = "< the node definition including the url"]
    pub node: *mut in3_node_t,
    #[doc = "< the current weight and blacklisting-stats"]
    pub weight: *mut in3_node_weight_t,
    #[doc = "< The starting value"]
    pub s: f32,
    #[doc = "< weight value"]
    pub w: f32,
    #[doc = "< next in the linkedlist or NULL if this is the last element"]
    pub next: *mut weight,
}
#[test]
fn bindgen_test_layout_weight() {
    assert_eq!(
        ::core::mem::size_of::<weight>(),
        32usize,
        concat!("Size of: ", stringify!(weight))
    );
    assert_eq!(
        ::core::mem::align_of::<weight>(),
        8usize,
        concat!("Alignment of ", stringify!(weight))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<weight>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(weight),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<weight>())).weight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(weight),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<weight>())).s as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(weight), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<weight>())).w as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(weight), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<weight>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(weight),
            "::",
            stringify!(next)
        )
    );
}
impl Clone for weight {
    fn clone(&self) -> Self {
        *self
    }
}
pub type node_match_t = weight;
#[doc = " The Request config."]
#[doc = ""]
#[doc = " This is generated for each request and represents the current state. it holds the state until the request is finished and must be freed afterwards."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_ctx {
    #[doc = " the type of the request"]
    pub type_: ctx_type_t,
    #[doc = " reference to the client"]
    pub client: *mut in3_t,
    #[doc = " the result of the json-parser for the request."]
    pub request_context: *mut json_ctx_t,
    #[doc = " the result of the json-parser for the response."]
    pub response_context: *mut json_ctx_t,
    #[doc = " in case of an error this will hold the message, if not it points to `NULL`"]
    pub error: *mut libc::c_char,
    #[doc = " the number of requests"]
    pub len: libc::c_int,
    #[doc = " the number of attempts"]
    pub attempt: libc::c_uint,
    #[doc = " references to the tokens representring the parsed responses"]
    pub responses: *mut *mut d_token_t,
    #[doc = " references to the tokens representring the requests"]
    pub requests: *mut *mut d_token_t,
    #[doc = " array of configs adjusted for each request."]
    pub requests_configs: *mut in3_request_config_t,
    pub nodes: *mut node_match_t,
    #[doc = " optional cache-entries."]
    #[doc = ""]
    #[doc = " These entries will be freed when cleaning up the context."]
    pub cache: *mut cache_entry_t,
    #[doc = " the raw response-data, which should be verified."]
    pub raw_response: *mut in3_response_t,
    #[doc = " pointer to the next required context. if not NULL the data from this context need get finished first, before being able to resume this context."]
    pub required: *mut in3_ctx,
    #[doc = " state of the verification"]
    pub verification_state: in3_ret_t,
}
#[test]
fn bindgen_test_layout_in3_ctx() {
    assert_eq!(
        ::core::mem::size_of::<in3_ctx>(),
        112usize,
        concat!("Size of: ", stringify!(in3_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).client as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).request_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(request_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).response_context as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(response_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).error as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).attempt as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(attempt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).responses as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(responses)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).requests as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).requests_configs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(requests_configs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).nodes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).cache as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).raw_response as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(raw_response)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).required as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(required)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_ctx>())).verification_state as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_ctx),
            "::",
            stringify!(verification_state)
        )
    );
}
impl Clone for in3_ctx {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_ctx_t = in3_ctx;
#[repr(i32)]
#[doc = " The current state of the context."]
#[doc = ""]
#[doc = " you can check this state after each execute-call."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum state {
    #[doc = "< The ctx has a verified result."]
    CTX_SUCCESS = 0,
    #[doc = "< there are required contexts, which need to be resolved first"]
    CTX_WAITING_FOR_REQUIRED_CTX = 1,
    #[doc = "< the response is not set yet"]
    CTX_WAITING_FOR_RESPONSE = 2,
    #[doc = "< the request has a error"]
    CTX_ERROR = -1,
}
pub use self::state as in3_ctx_state_t;
extern "C" {
    #[doc = " sends a previously created context to nodes and verifies it."]
    #[doc = ""]
    #[doc = " The execution happens within the same thread, thich mean it will be blocked until the response ha beedn received and verified."]
    #[doc = " In order to handle calls asynchronously, you need to call the `in3_ctx_execute` function and provide the data as needed."]
    pub fn in3_send_ctx(ctx: *mut in3_ctx_t) -> in3_ret_t;
}
extern "C" {
    #[doc = " tries to execute the context, but stops whenever data are required."]
    #[doc = ""]
    #[doc = " This function should be used in order to call data in a asyncronous way,"]
    #[doc = " since this function will not use the transport-function to actually send it."]
    #[doc = ""]
    #[doc = " The caller is responsible for delivering the required responses."]
    #[doc = " After calling you need to check the return-value:"]
    #[doc = " - IN3_WAITING : provide the required data and then call in3_ctx_execute again."]
    #[doc = " - IN3_OK : success, we have a result."]
    #[doc = " - any other status = error"]
    #[doc = ""]
    #[doc = " Here is a example how to use this function:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = ""]
    #[doc = "in3_ret_t in3_send_ctx(in3_ctx_t* ctx) {"]
    #[doc = "in3_ret_t ret;"]
    #[doc = "while ((ret = in3_ctx_execute(ctx))) {"]
    #[doc = "if (ret != IN3_WAITING) return ret;"]
    #[doc = ""]
    #[doc = "while (ctx->required && in3_ctx_state(ctx->required) != CTX_SUCCESS) {"]
    #[doc = "if ((ret = in3_send_ctx(ctx->required))) return ret;"]
    #[doc = ""]
    #[doc = "if ((ret = in3_ctx_execute(ctx)) != IN3_WAITING) return ret;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if (!ctx->raw_response) {"]
    #[doc = ""]
    #[doc = "switch (ctx->type) {"]
    #[doc = ""]
    #[doc = "case CT_RPC: {"]
    #[doc = ""]
    #[doc = "in3_request_t* request = in3_create_request(ctx);"]
    #[doc = ""]
    #[doc = "ctx->client->transport(request);"]
    #[doc = ""]
    #[doc = "request_free(request, ctx, false);"]
    #[doc = "break;"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "case CT_SIGN: {"]
    #[doc = "d_token_t* params = d_get(ctx->requests[0], K_PARAMS);"]
    #[doc = "bytes_t    data   = d_to_bytes(d_get_at(params, 0));"]
    #[doc = "bytes_t    from   = d_to_bytes(d_get_at(params, 1));"]
    #[doc = ""]
    #[doc = "ctx->raw_response = _malloc(sizeof(in3_response_t));"]
    #[doc = "sb_init(&ctx->raw_response[0].error);"]
    #[doc = "sb_init(&ctx->raw_response[0].result);"]
    #[doc = ""]
    #[doc = "uint8_t sig[65];"]
    #[doc = "ret = ctx->client->signer->sign(ctx, SIGN_EC_HASH, data, from, sig);"]
    #[doc = "if (ret < 0) return ctx_set_error(ctx, ctx->raw_response->error.data, ret);"]
    #[doc = "sb_add_range(&ctx->raw_response->result, (char*) sig, 0, 65);"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "return ret;"]
    #[doc = "}"]
    #[doc = " ```"]
    pub fn in3_ctx_execute(ctx: *mut in3_ctx_t) -> in3_ret_t;
}
extern "C" {
    #[doc = " returns the current state of the context."]
    pub fn in3_ctx_state(ctx: *mut in3_ctx_t) -> in3_ctx_state_t;
}
extern "C" {
    #[doc = " creates a request-object, which then need to be filled with the responses."]
    #[doc = ""]
    #[doc = " each request object contains a array of reponse-objects. In order to set the response, you need to call"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " // set a succesfull response"]
    #[doc = " sb_add_chars(&request->results[0].result, my_response);"]
    #[doc = " // set a error response"]
    #[doc = " sb_add_chars(&request->results[0].error, my_error);"]
    #[doc = " ```"]
    pub fn in3_create_request(ctx: *mut in3_ctx_t) -> *mut in3_request_t;
}
extern "C" {
    #[doc = " sends a request and returns a context used to access the result or errors."]
    #[doc = ""]
    #[doc = " This context *MUST* be freed with ctx_free(ctx) after usage to release the resources."]
    pub fn in3_client_rpc_ctx_raw(c: *mut in3_t, request: *mut libc::c_char) -> *mut in3_ctx_t;
}
extern "C" {
    #[doc = " sends a request and returns a context used to access the result or errors."]
    #[doc = ""]
    #[doc = " This context *MUST* be freed with ctx_free(ctx) after usage to release the resources."]
    pub fn in3_client_rpc_ctx(
        c: *mut in3_t,
        method: *mut libc::c_char,
        params: *mut libc::c_char,
    ) -> *mut in3_ctx_t;
}
#[doc = " verification context holding the pointers to all relevant toknes."]
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in3_vctx_t {
    #[doc = "< Request context."]
    pub ctx: *mut in3_ctx_t,
    #[doc = "< the chain definition."]
    pub chain: *mut in3_chain_t,
    #[doc = "< the result to verify"]
    pub result: *mut d_token_t,
    #[doc = "< the request sent."]
    pub request: *mut d_token_t,
    #[doc = "< the delivered proof."]
    pub proof: *mut d_token_t,
    #[doc = "< Request configuration."]
    pub config: *mut in3_request_config_t,
    #[doc = "< Block number of last change of the validator list"]
    pub last_validator_change: u64,
    #[doc = "< Block number of latest block"]
    pub currentBlock: u64,
}
#[test]
fn bindgen_test_layout_in3_vctx_t() {
    assert_eq!(
        ::core::mem::size_of::<in3_vctx_t>(),
        64usize,
        concat!("Size of: ", stringify!(in3_vctx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<in3_vctx_t>(),
        8usize,
        concat!("Alignment of ", stringify!(in3_vctx_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_vctx_t>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_vctx_t>())).chain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_vctx_t>())).result as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_vctx_t>())).request as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_vctx_t>())).proof as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(proof)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_vctx_t>())).config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in3_vctx_t>())).last_validator_change as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(last_validator_change)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in3_vctx_t>())).currentBlock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(in3_vctx_t),
            "::",
            stringify!(currentBlock)
        )
    );
}
impl Clone for in3_vctx_t {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = " function to verify the result."]
pub type in3_verify = ::core::option::Option<unsafe extern "C" fn(c: *mut in3_vctx_t) -> in3_ret_t>;
#[doc = " function which is called to fill the response before a request is triggered."]
#[doc = " This can be used to handle requests which don't need a node to response."]
pub type in3_pre_handle = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut in3_ctx_t, response: *mut *mut in3_response_t) -> in3_ret_t,
>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct verifier {
    pub verify: in3_verify,
    pub pre_handle: in3_pre_handle,
    pub type_: in3_chain_type_t,
    pub next: *mut verifier,
}
#[test]
fn bindgen_test_layout_verifier() {
    assert_eq!(
        ::core::mem::size_of::<verifier>(),
        32usize,
        concat!("Size of: ", stringify!(verifier))
    );
    assert_eq!(
        ::core::mem::align_of::<verifier>(),
        8usize,
        concat!("Alignment of ", stringify!(verifier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<verifier>())).verify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(verifier),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<verifier>())).pre_handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(verifier),
            "::",
            stringify!(pre_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<verifier>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(verifier),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<verifier>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(verifier),
            "::",
            stringify!(next)
        )
    );
}
impl Clone for verifier {
    fn clone(&self) -> Self {
        *self
    }
}
pub type in3_verifier_t = verifier;
extern "C" {
    #[doc = " returns the verifier for the given chainType"]
    pub fn in3_get_verifier(type_: in3_chain_type_t) -> *mut in3_verifier_t;
}
extern "C" {
    pub fn in3_register_verifier(verifier: *mut in3_verifier_t);
}
extern "C" {
    #[doc = " entry-function to execute the verification context."]
    pub fn in3_verify_eth_basic(v: *mut in3_vctx_t) -> in3_ret_t;
}
extern "C" {
    #[doc = " this function should only be called once and will register the eth-nano verifier."]
    pub fn in3_register_eth_basic();
}
extern "C" {
    #[doc = " registers curl as a default transport."]
    pub fn in3_register_curl();
}
