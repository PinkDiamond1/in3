in3:

  in3_abiEncode:
    descr: based on the [ABI-encoding](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html) used by solidity, this function encodes the value given and returns it as hexstring.
    params:
      signature:
        type: string
        descr: the signature of the function. e.g. `getBalance(uint256)`. The format is the same as used by solidity to create the functionhash. optional you can also add the return type, which in this case is ignored.
      params:
        type: array
        descr: a array of arguments. the number of arguments must match the arguments in the signature.
    returns:
      type: hex
      descr: the ABI-encoded data as hex including the 4 byte function-signature. These data can be used for `eth_call` or to send a transaction.
    example:
      request:
        - "getBalance(address)"
        - ["0x1234567890123456789012345678901234567890"]
      response: "0xf8b2cb4f0000000000000000000000001234567890123456789012345678901234567890"

  in3_abiDecode:
    descr: based on the [ABI-encoding](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html) used by solidity, this function decodes the bytes given and returns it as array of values.
    params:
      signature:
        type: string
        descr: the signature of the function. e.g. `uint256`, `(address,string,uint256)` or `getBalance(address):uint256`. If the complete functionhash is given, only the return-part will be used.
      data:
        type: hex
        descr: the data to decode (usually the result of a eth_call)
    returns:
      type: array
      descr: a array (if more then one arguments in the result-type) or the the value after decodeing.
    example:
      request:
        - (address,uint256)
        - "0x00000000000000000000000012345678901234567890123456789012345678900000000000000000000000000000000000000000000000000000000000000005"
      response: 
        - "0x1234567890123456789012345678901234567890"
        - "0x05"

  in3_checksumAddress:
    descr: Will convert an upper or lowercase Ethereum address to a checksum address.  (See [EIP55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md) )
    params:
      address:
        descr: the address to convert.
        type: address
      useChainId:
        descr: if true, the chainId is integrated as well (See [EIP1191](https://github.com/ethereum/EIPs/issues/1121) )
        type: bool
        optional: true
    returns:
      descr: the address-string using the upper/lowercase hex characters.
    example:
      request:
        - "0x1fe2e9bf29aa1938859af64c413361227d04059a"
        - false
      response: "0x1Fe2E9bf29aa1938859Af64C413361227d04059a"

  
  in3_ens:
    descr: | 
      resolves a ens-name. 
      the domain names consist of a series of dot-separated labels. Each label must be a valid normalised label as described in [UTS46](https://unicode.org/reports/tr46/) with the options `transitional=false` and `useSTD3AsciiRules=true`. 
      For Javascript implementations, a [library](https://www.npmjs.com/package/idna-uts46) is available that normalises and checks names.
    params:
      name:
        descr: the domain name UTS46 compliant string.
        type: string
      field:
        descr: the required data, which could be one of ( `addr` - the address, `resolver` - the address of the resolver, `hash` - the namehash, `owner` - the owner of the domain)
        type: string
        optional: true
        default: addr
    returns:
      descr: the value of the specified field
    example:
      request:
        - cryptokitties.eth
        - addr
      response: "0x1Fe2E9bf29aa1938859Af64C413361227d04059a"

  


  in3_toWei:
    descr: converts the given value into wei.
    params:
      value:
        descr: the value, which may be floating number as string
        type: string or uint
        example: "0.9"
      unit:
        descr: the unit of the value, which must be one of `wei`, `kwei`,  `Kwei`,  `babbage`,  `femtoether`,  `mwei`,  `Mwei`,  `lovelace`,  `picoether`,  `gwei`,  `Gwei`,  `shannon`,  `nanoether`,  `nano`,  `szabo`,  `microether`,  `micro`,  `finney`,  `milliether`,  `milli`,  `ether`,  `eth`,  `kether`,  `grand`,  `mether`,  `gether` or  `tether`
        type: string
        optional: true
        default: eth
    returns:
      descr: the value in wei as hex.
    example:
      request:
        - "20.0009123"
        - eth
      response: "0x01159183c4793db800"

  
  in3_fromWei:
    descr: converts a given uint (also as hex) with a wei-value into a specified unit.
    params:
      value:
        descr: the value in wei
        type: uint or bytes
        example: "0x234324abdef"
      unit:
        descr: the unit of the target value, which must be one of `wei`, `kwei`,  `Kwei`,  `babbage`,  `femtoether`,  `mwei`,  `Mwei`,  `lovelace`,  `picoether`,  `gwei`,  `Gwei`,  `shannon`,  `nanoether`,  `nano`,  `szabo`,  `microether`,  `micro`,  `finney`,  `milliether`,  `milli`,  `ether`,  `eth`,  `kether`,  `grand`,  `mether`,  `gether` or  `tether`
        type: string
      digits:
        descr: fix number of digits after the comma. If left out, only as many as needed will be included. 
        type: uint
        optional: true
    returns:
      descr: the value as string.
    example:
      request:
        - "0x234324abadefdef"
        - eth
        - 3
      response: "0.158"

  in3_pk2address:
    descr: extracts the address from a private key.
    params:
      pk:
        descr: the 32 bytes private key as hex.
        type: bytes32
    returns:
      descr: the address
    example:
      request:
        - "0x0fd65f7da55d811634495754f27ab318a3309e8b4b8a978a50c20a661117435a"
      response: "0xdc5c4280d8a286f0f9c8f7f55a5a0c67125efcfd"

  in3_pk2public:
    descr: extracts the public key from a private key.
    params:
      pk:
        descr: the 32 bytes private key as hex.
        type: bytes32
    returns:
      descr: the public key as 64 bytes
    example:
      request:
        - "0x0fd65f7da55d811634495754f27ab318a3309e8b4b8a978a50c20a661117435a"
      response: "0x0903329708d9380aca47b02f3955800179e18bffbb29be3a644593c5f87e4c7fa960983f78186577eccc909cec71cb5763acd92ef4c74e5fa3c43f3a172c6de1"

  in3_ecrecover:
    descr: extracts the public key and address from signature.
    params:
      msg:
        descr: the message the signature is based on.
        type: hex
      sig:
        descr:  the 65 bytes signature as hex.
        type: bytes
      sigtype:
        descr: "the type of the signature data : `eth_sign` (use the prefix and hash it), `raw` (hash the raw data), `hash` (use the already hashed data). Default: `raw`"
        type: string
        default: raw
        optional: true
    returns:
      descr: the extracted public key and address
      type:
        publicKey:
          descr: the public Key of the signer (64 bytes)
          type: bytes
        address:
          descr: the address
          type: address
    example:
      request:
        - "0x487b2cbb7997e45b4e9771d14c336b47c87dc2424b11590e32b3a8b9ab327999"
        - "0x0f804ff891e97e8a1c35a2ebafc5e7f129a630a70787fb86ad5aec0758d98c7b454dee5564310d497ddfe814839c8babd3a727692be40330b5b41e7693a445b71c"
        - hash
      response:
        publicKey: "0x94b26bafa6406d7b636fbb4de4edd62a2654eeecda9505e9a478a66c4f42e504c4481bad171e5ba6f15a5f11c26acfc620f802c6768b603dbcbe5151355bbffb"
        address: "0xf68a4703314e9a9cf65be688bd6d9b3b34594ab4"
      

  in3_prepareTx:
    descr: prepares a Transaction by filling the unspecified values and returens the unsigned raw Transaction.
    params:
      tx:
        descr: the tx-object, which is the same as specified in [eth_sendTransaction](https://eth.wiki/json-rpc/API#eth_sendTransaction).
        type:
          to:
            descr: receipient of the transaction.
            type: address
          from:
            descr: sender of the address (if not sepcified, the first signer will be the sender)
            type: address
          value:
            descr: value in wei to send
            type: uint
            optional: true
          gas:
            descr: the gas to be send along
            type: uint
            optional: true
            default: 21000
          gasPrice:
            descr: the price in wei for one gas-unit. If not specified it will be fetched using `eth_gasPrice`
            type: uint
            optional: true
          nonce:
            descr: the current nonce of the sender. If not specified it will be fetched using `eth_getTransactionCount`
            type: uint
            optional: true
          
    returns:
      descr: the unsigned raw transaction as hex.
    example:
      request:
        -  to: "0x63f666a23cbd135a91187499b5cc51d589c302a0"
           value: "0x100000000"
           from: "0xc2b2f4ad0d234b8c135c39eea8409b448e5e496f" 
      response: "0xe980851a13b865b38252089463f666a23cbd135a91187499b5cc51d589c302a085010000000080018080"

  in3_signTx:
    descr: signs the given raw Tx (as prepared by in3_prepareTx ). The resulting data can be used in `eth_sendRawTransaction` to publish and broadcast the transaction.
    params:
      tx:
        descr: the raw unsigned transactiondata
        type: hex
      from:
        descr: the account to sign
        type: address
          
    returns:
      descr: the raw transaction with signature.
    example:
      request:
        - "0xe980851a13b865b38252089463f666a23cbd135a91187499b5cc51d589c302a085010000000080018080"
        - "0xc2b2f4ad0d234b8c135c39eea8409b448e5e496f"
      response: "0xf86980851a13b865b38252089463f666a23cbd135a91187499b5cc51d589c302a08501000000008026a03c5b094078383f3da3f65773ab1314e89ee76bc41f827f2ef211b2d3449e4435a077755f8d9b32966e1ad8f6c0e8c9376a4387ed237bdbf2db6e6b94016407e276"

  in3_signData:
    descr: signs the given data.
    params:
      msg:
        descr: the message to sign.
        type: hex
      account:
        descr: the account to sign if the account is a bytes32 it will be used as private key
        type: address | bytes32
      msgType:
        descr: "the type of the signature data : `eth_sign` (use the prefix and hash it), `raw` (hash the raw data), `hash` (use the already hashed data)"
        type: string
        default: raw
        optional: true
        
    returns:
      descr: the signature
      type:
        message:
          descr: original message used
          type: bytes
        messageHash:
          descr: the hash the signature is based on
          type: bytes32
        signature:
          descr: the signature (65 bytes)
          type: bytes
        r:
          descr: the x-value of the EC-Point
          type: bytes32
        s:
          descr: the y-value of the EC-Point
          type: bytes32
        v:
          descr: the recovery value (0|1) + 27
          type: byte

    example:
      request:
        - "0x0102030405060708090a0b0c0d0e0f"
        - "0xa8b8759ec8b59d7c13ef3630e8530f47ddb47eba12f00f9024d3d48247b62852"
        - raw
      response: 
        message: "0x0102030405060708090a0b0c0d0e0f"
        messageHash: "0x1d4f6fccf1e27711667605e29b6f15adfda262e5aedfc5db904feea2baa75e67"
        signature: "0xa5dea9537d27e4e20b6dfc89fa4b3bc4babe9a2375d64fb32a2eab04559e95792264ad1fb83be70c145aec69045da7986b95ee957fb9c5b6d315daa5c0c3e1521b"
        r: "0xa5dea9537d27e4e20b6dfc89fa4b3bc4babe9a2375d64fb32a2eab04559e9579"
        s: "0x2264ad1fb83be70c145aec69045da7986b95ee957fb9c5b6d315daa5c0c3e152"
        v: 27

  in3_decryptKey:
    descr: decrypts a JSON Keystore file as defined in the [Web3 Secret Storage Definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition). The result is the raw private key.
    params:
      key:
        descr: Keydata as object as defined in the keystorefile
        type: object
      passphrase:
        descr: the password to decrypt it.
        type: string

    returns:
      descr: a raw private key (32 bytes)
    example:
      request:
        - version: 3,
          id: "f6b5c0b1-ba7a-4b67-9086-a01ea54ec638"
          address: "08aa30739030f362a8dd597fd3fcde283e36f4a1"
          crypto: 
            ciphertext: "d5c5aafdee81d25bb5ac4048c8c6954dd50c595ee918f120f5a2066951ef992d"
            cipherparams: 
              iv: "415440d2b1d6811d5c8a3f4c92c73f49"
            cipher: "aes-128-ctr"
            kdf: pbkdf2
            kdfparams: 
              dklen: 32
              salt: "691e9ad0da2b44404f65e0a60cf6aabe3e92d2c23b7410fd187eeeb2c1de4a0d"
              c: 16384
              prf: hmac-sha256
            mac: "de651c04fc67fd552002b4235fa23ab2178d3a500caa7070b554168e73359610"
        - test
      response: "0x1ff25594a5e12c1e31ebd8112bdf107d217c1393da8dc7fc9d57696263457546"

  in3_cacheClear:
    descr: clears the incubed cache (usually found in the .in3-folder)
    returns:
      descr: true indicating the success
    example: 
      request: []
      response: true

  in3_nodeList:
    descr: clears the incubed cache (usually found in the .in3-folder)
    params:
      limit:
        descr: if the number is defined and >0 this method will return a partial nodeList limited to the given number.
        type: uint
        optional: true
      seed:
        descr: this 32byte hex integer is used to calculate the indexes of the partial nodeList. It is expected to be a random value choosen by the client in order to make the result deterministic.
        type: bytes32
        optional: true
      addresses:
        descr: a optional array of addresses of signers the nodeList must include.
        type: address[]
        optional: true

    returns:
      descr: the current nodelist
      type:
        nodes:
          descr: a array of node definitions.
          type:
            url:
              descr: the url of the node. Currently only http/https is supported, but in the future this may even support onion-routing or any other protocols.
              type: string
            address:
              descr: the address of the signer
              type: address
            index:
              descr: the index within the nodeList of the contract
              type: uint
            deposit:
              descr: the stored deposit
              type: uint
            props:
              descr: the bitset of capabilities as described in the [Node Structure](spec.html#node-structure)
              type: uint
            timeout:
              descr: the time in seconds describing how long the deposit would be locked when trying to unregister a node.
              type: uint
            registerTime:
              descr: unix timestamp in seconds when the node has registered.
              type: uint
            weight:
              descr: the weight of a node ( not used yet ) describing the amount of request-points it can handle per second.
              type: uint
            proofHash:
              descr: | 
                a hash value containing the above values. 
                This hash is explicitly stored in the contract, which enables the client to have only one merkle proof 
                per node instead of verifying each property as its own storage value. 
                The proof hash is build `keccak256( abi.encodePacked( deposit, timeout, registerTime, props, signer, url ))` 
              type: bytes32
        contract:
          descr: the address of the Incubed-storage-contract. The client may use this information to verify that we are talking about the same contract or throw an exception otherwise.
          type: address
        registryId:
          descr: the registryId (32 bytes)  of the contract, which is there to verify the correct contract.
          type: bytes32
        lastBlockNumber:
          descr: the blockNumber of the last change of the list (usually the last event). 
          type: uint
        totalServer:
          descr: the total numbers of nodes.
          type: uint
    
    proof:
      descr: |
        if proof is requested, the proof will have the type `accountProof`. In the proof-section only the storage-keys of the `proofHash` will be included.
        The required storage keys are calcualted :

        - `0x00` - the length of the nodeList or total numbers of nodes.
        - `0x01` - the registryId
        - per node : ` 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563 + index * 5 + 4`

        The blockNumber of the proof must be the latest final block (`latest`- minBlockHeight) and always greater or equal to the `lastBlockNumber` 

        #### Partial NodeLists

        if the client requests a partial nodeList and the given limit is smaller then the total amount of nodes, the server needs to pick nodes in a deterministic way. This is done by using the given seed.

        1. add all required addresses (if any) to the list.
        2. iterate over the indexes until the limit is reached:

            ```ts
            function createIndexes(total: number, limit: number, seed: Buffer): number[] {
              const result: number[] = []              // the result as a list of indexes
              let step = seed.readUIntBE(0, 6)         // first 6 bytes define the step size
              let pos  = seed.readUIntBE(6, 6) % total // next 6 bytes define the offset
              while (result.length < limit) {
                if (result.indexOf(pos) >= 0) {        // if the index is already part of the result
                  seed = keccak256(seed)               // we create a new seed by hashing the seed.
                  step = seed.readUIntBE(0, 6)         // and change the step-size
                } 
                else
                  result.push(pos)
                pos = (pos + step) % total             // use the modulo operator to calculate the next position.
              }
              return result
            }
            ````
      type:
        type:
          descr: the proofType
          type: "accountProof"
        block: 
          descr: the serialized blockheader of the latest final block
          type: bytes
        signatures:
          descr:  a array of signatures from the signers (if requested) of the above block.
          type: bytes[]
        accounts:
          descr: a Object with the addresses of the db-contract as key and Proof as value. The Data Structure of the Proof is exactly the same as the result of - [`eth_getProof`](https://eth.wiki/json-rpc/API#eth_getproof), but it must contain the above described keys.
          type: 
            "<accountAdr>":
              descr: The Account of the data-contract.
              type:
                address:
                  descr: the address of the account
                  type: address
                balance: 
                  descr: current Balance
                  type: uint
                codeHash:
                  descr: hash of the contract code
                  type: bytes32
                nonce:
                  descr: nonce of the account
                  type: uint
                storageHash:
                  descr: MerkleRoot of the Storage Trie
                  type: bytes32
                accountProof:
                  descr: MerkleProof of this account-node
                  type: bytes[]
                storageProof:
                  descr: Array of Proofs for all required storage values
                  type:
                    key:
                      descr: the storage key (or hash)
                      type: uint
                    value:
                      descr: the storage value
                      type: bytes32
                    proof:
                      descr: the merkleProof of the value down to the storageHash as MerkleRoot
                      type: bytes[]
    example:
      request:
        - 2
        - "0xe9c15c3b26342e3287bb069e433de48ac3fa4ddd32a31b48e426d19d761d7e9b"
        - []
      response:
        totalServers: 5
        contract: "0x64abe24afbba64cae47e3dc3ced0fcab95e4edd5"
        registryId: "0x423dd84f33a44f60e5d58090dcdcc1c047f57be895415822f211b8cd1fd692e3"
        lastBlockNumber: 8669495
        nodes: 
          - url: "https://in3-v2.slock.it/mainnet/nd-3"
            address: "0x945F75c0408C0026a3CD204d36f5e47745182fd4"
            index: 2
            deposit: "10000000000000000"
            props: 29
            timeout: 3600
            registerTime: 1570109570
            weight: 2000
            proofHash: "0x27ffb9b7dc2c5f800c13731e7c1e43fb438928dd5d69aaa8159c21fb13180a4c"
          - url: "https://in3-v2.slock.it/mainnet/nd-5"
            address: "0xbcdF4E3e90cc7288b578329efd7bcC90655148d2"
            index: 4
            deposit: "10000000000000000"
            props: 29
            timeout: 3600
            registerTime: 1570109690
            weight: 2000
            proofHash: "0xd0dbb6f1e28a8b90761b973e678cf8ecd6b5b3a9d61fb9797d187be011ee9ec7"
      in3:
        proof:
          type: accountProof
          block: "0xf9021ca01...."
          accounts:
            "0x64abe24afbba64cae47e3dc3ced0fcab95e4edd5":
              address: "0x64abe24afbba64cae47e3dc3ced0fcab95e4edd5"
              balance: "0xb1a2bc2ec50000"
              codeHash: "0x18e64869905158477a607a68e9c0074d78f56a9dd5665a5254f456f89d5be398"
              nonce: "0x1"
              storageHash: "0x4386ec93bd665ea07d7ed488e8b495b362a31dc4100cf762b22f4346ee925d1f"
              accountProof: 
                - "0xf90211a0e822..."
                - "0xf90211a0f6d0..."
                - "0xf90211a04d7b..."
                - "0xf90211a0e749..."
                - "0xf90211a059cb..."
                - "0xf90211a0568f..."
                - "0xf8d1a0ac2433..."
                - "0xf86d9d33b981..."
              storageProof:
                - key: "0x0"
                  proof: 
                    - "0xf90211a0ccb6d2d5786..."
                    - "0xf871808080808080800..."
                    - "0xe2a0200decd9548b62a...05"
                  value: "0x5"
                - key: "0x1"
                  proof: 
                    - "0xf90211a0ccb6d2d5786..."
                    - "0xf871808080808080800..."
                    - "0xf843a0200e2d5276120...423dd84f33a44f60e5d58090dcdcc1c047f57be895415822f211b8cd1fd692e3"
                  value: "0x423dd84f33a44f60e5d58090dcdcc1c047f57be895415822f211b8cd1fd692e3"

